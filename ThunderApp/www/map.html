<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Routing -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css">
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

    <style>
        html, body { height: 100%; margin: 0; }
        #mapWrap { height: 100%; width: 100%; position: relative; }
        #map { height: 100%; width: 100%; }

        .leaflet-routing-container {
            background: rgba(0,0,0,0.8);
            color: white;
        }
    
        .radar-overlay{
            position: absolute;
            left: 50%;
            bottom: 16px;
            transform: translateX(-50%);
            z-index: 500;
            pointer-events: none; /* enable clicks only on the bar */
        }

        .radar-overlay.hidden{ display:none; }

        .radar-bar{
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(15,23,42,0.88);
            color: #e5e7eb;
            border: 1px solid rgba(51,65,85,0.9);
            border-radius: 12px;
            padding: 8px 10px;
            font: 13px "Segoe UI", sans-serif;
            box-shadow: 0 8px 24px rgba(0,0,0,0.35);
        }

        .radar-btn{
            min-width: 38px;
            height: 32px;
            background: rgba(31,41,55,0.95);
            color: #e5e7eb;
            border: 1px solid rgba(51,65,85,0.9);
            border-radius: 8px;
            cursor: pointer;
        }

        .radar-btn:hover{ filter: brightness(1.15); }

        .radar-text{
            display:flex;
            flex-direction:column;
            line-height: 1.15;
            min-width: 210px;
        }

        .radar-line{ white-space: nowrap; }
        .radar-muted{ color: rgba(229,231,235,0.72); font-size: 12px; }

        .station-model{ position:relative; width:96px; height:62px; pointer-events:none; filter: drop-shadow(0 0 3px rgba(0,0,0,0.95)); }
        .station-model .dot{ position:absolute; left:41px; top:26px; width:12px; height:12px; border-radius:50%; border:2px solid #0b1220; }
        .station-model.active .dot{ background:#fb923c; border-color:#f97316; }
        .station-model.idle .dot{ background:#7dd3fc; border-color:#38bdf8; }
        .station-model .temp{ position:absolute; left:0; top:0; font:700 14px "Segoe UI"; color:#f8fafc; text-shadow:0 1px 2px #000; }
        .station-model .dew{ position:absolute; left:0; bottom:0; font:700 14px "Segoe UI"; color:#93c5fd; text-shadow:0 1px 2px #000; }
        .station-model .wind{ position:absolute; right:0; top:0; font:700 12px "Segoe UI"; color:#f8fafc; text-shadow:0 1px 2px #000; text-align:right; }
</style>
</head>
<body>
<div id="mapWrap">
    <div id="map"></div>

    <!-- Floating radar controls (shown only when radar is enabled) -->
    <div id="radarOverlay" class="radar-overlay hidden" aria-hidden="true">
        <div class="radar-bar">
            <button class="radar-btn" data-act="start" title="Go to oldest frame">⏮</button>
            <button class="radar-btn" data-act="rew" title="Rewind">⏪</button>
            <button class="radar-btn" data-act="play" title="Play">▶</button>
            <button class="radar-btn" data-act="pause" title="Pause">⏸</button>
            <button class="radar-btn" data-act="fwd" title="Forward">⏩</button>
            <button class="radar-btn" data-act="end" title="Go to newest frame">⏭</button>

            <div class="radar-text">
                <div id="radarFrameStamp" class="radar-line"></div>
                <div id="radarRefreshStamp" class="radar-line radar-muted"></div>
            </div>
        </div>
    </div>
</div>

<script>
// Opacity multipliers (0..1). Controlled by WPF sliders.
let alertsOpacityFactor = 1.0;
let spcOpacityFactor = 1.0;
function __clamp01(x){ x=parseFloat(x); if(isNaN(x)) return 1.0; return Math.max(0.0, Math.min(1.0, x)); }
window.setAlertsOpacity = function(v){ alertsOpacityFactor = __clamp01(v); if(window.alertLayer){ window.alertLayer.setStyle(alertStyle);} };
window.setSpcOpacity = function(v){
    spcOpacityFactor = __clamp01(v);
    if (window.spc && window.spc.layers) {
        Object.values(window.spc.layers).forEach(lyr => { try { lyr.setStyle(spcStyle); } catch {} });
    }
};


    // =======================
    // Map Base
    // =======================
    const map = L.map('map', { zoomControl: true, doubleClickZoom: false }).setView([39.5, -98.35], 4);

    const baseLayers = {
        light: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18 }),
        dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', { maxZoom: 19 })
    };
    let currentBase = 'dark';
    baseLayers[currentBase].addTo(map);

    window.setMapTheme = (theme) => {
        const next = (String(theme || '').toLowerCase() === 'light') ? 'light' : 'dark';
        if (next === currentBase) return;
        try { map.removeLayer(baseLayers[currentBase]); } catch {}
        currentBase = next;
        baseLayers[currentBase].addTo(map);
    };

    // =======================
    // SVG defs (pattern + glow) for severity overlays
    // =======================
    let _defsReady = false;
    function ensureSvgDefs() {
        if (_defsReady) return;
        const svg = map.getPanes().overlayPane.querySelector('svg');
        if (!svg) return;

        let defs = svg.querySelector('defs');
        if (!defs) {
            defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            svg.insertBefore(defs, svg.firstChild);
        }

        // Diagonal stripes pattern (used for Extreme severity)
        if (!svg.querySelector('#diagStripes')) {
            const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            pattern.setAttribute('id', 'diagStripes');
            pattern.setAttribute('patternUnits', 'userSpaceOnUse');
            pattern.setAttribute('width', '10');
            pattern.setAttribute('height', '10');
            pattern.setAttribute('patternTransform', 'rotate(45)');

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', '10');
            rect.setAttribute('height', '10');
            rect.setAttribute('fill', 'transparent');
            pattern.appendChild(rect);

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            line.setAttribute('x', '0');
            line.setAttribute('y', '0');
            line.setAttribute('width', '4');
            line.setAttribute('height', '10');
            line.setAttribute('fill', 'rgba(255,255,255,0.25)');
            pattern.appendChild(line);

            defs.appendChild(pattern);
        }

        // Glow filter (used for Extreme severity)
        if (!svg.querySelector('#sevGlow')) {
            const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            filter.setAttribute('id', 'sevGlow');
            filter.setAttribute('x', '-50%');
            filter.setAttribute('y', '-50%');
            filter.setAttribute('width', '200%');
            filter.setAttribute('height', '200%');

            const blur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
            blur.setAttribute('in', 'SourceGraphic');
            blur.setAttribute('stdDeviation', '2.2');
            blur.setAttribute('result', 'blurOut');

            const merge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
            const m1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
            m1.setAttribute('in', 'blurOut');
            const m2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
            m2.setAttribute('in', 'SourceGraphic');

            merge.appendChild(m1);
            merge.appendChild(m2);

            filter.appendChild(blur);
            filter.appendChild(merge);
            defs.appendChild(filter);
        }

        _defsReady = true;
    }

    // try soon + whenever layers are added
    setTimeout(ensureSvgDefs, 250);
    map.on('layeradd', () => setTimeout(ensureSvgDefs, 0));


    // =======================
    // State
    // =======================
    let followEnabled = true;
    let gpsMarker = null;
    let routingControl = null;
    let radarLayer = null;

    // Range circle
    let rangeCircle = null;
    let rangeCircleEnabled = false;
    let rangeCircleMiles = 50;

    let trailPoints = [];
    const TRAIL_MAX_POINTS = 300;

    let lastZoom = map.getZoom();

    // =======================
    // GPS Marker + Trail
    // =======================
    const trailLine = L.polyline([], {
        weight: 3,
        opacity: 0.9
    }).addTo(map);

    function ensureMarker(lat, lon) {
        if (!gpsMarker) {
            gpsMarker = L.circleMarker([lat, lon], {
                radius: 8,
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(map);
        } else {
            gpsMarker.setLatLng([lat, lon]);
        }
    }

    function addTrailPoint(lat, lon) {
        trailPoints.push([lat, lon]);
        if (trailPoints.length > TRAIL_MAX_POINTS)
            trailPoints.shift();
        trailLine.setLatLngs(trailPoints);
    }

    // =======================
    // Exposed API (C#)
    // =======================
    window.setFollow = (enabled) => followEnabled = !!enabled;

    window.clearTrail = () => {
        trailPoints = [];
        trailLine.setLatLngs(trailPoints);
    };

    window.setView = (lat, lon, zoom) => {
        lastZoom = zoom;
        map.setView([lat, lon], zoom);
    };

    window.updateGps = (lat, lon, zoom, addToTrail) => {
        ensureMarker(lat, lon);
        if (addToTrail) addTrailPoint(lat, lon);

        // keep range circle centered on GPS
        if (rangeCircleEnabled) {
            ensureRangeCircle(lat, lon, rangeCircleMiles);
        }

        if (followEnabled) {
            if (typeof zoom === "number" && zoom !== lastZoom) {
                lastZoom = zoom;
                map.setView([lat, lon], zoom, { animate: true });
            } else {
                map.panTo([lat, lon], { animate: true });
            }
        }
    };

    // =======================
    // Range Circle (miles)
    // =======================

    function ensureRangeCircle(lat, lon, miles) {
        const meters = (miles || 0) * 1609.344;
        if (!rangeCircle) {
            rangeCircle = L.circle([lat, lon], {
                radius: meters,
                weight: 2,
                opacity: 0.9,
                fillOpacity: 0.06
            }).addTo(map);
        } else {
            rangeCircle.setLatLng([lat, lon]);
            rangeCircle.setRadius(meters);
        }
    }

    window.setRangeCircle = (lat, lon, enabled, miles) => {
        rangeCircleEnabled = !!enabled;
        rangeCircleMiles = (typeof miles === "number") ? miles : parseFloat(miles);

        if (!rangeCircleEnabled) {
            if (rangeCircle) {
                map.removeLayer(rangeCircle);
                rangeCircle = null;
            }
            return;
        }

        if (typeof lat !== "number") lat = parseFloat(lat);
        if (typeof lon !== "number") lon = parseFloat(lon);

        // Prefer GPS marker center if available
        if (gpsMarker) {
            const p = gpsMarker.getLatLng();
            ensureRangeCircle(p.lat, p.lng, rangeCircleMiles);
        } else {
            ensureRangeCircle(lat, lon, rangeCircleMiles);
        }
    };


    // =======================
    // Weather stations (ASOS)
    // =======================
    const wxStations = {
        layer: L.layerGroup().addTo(map),
        byId: new Map(),
        activeId: null,
        visible: true,
        payload: null
    };

    function formatObsPopup(st) {
        const obs = st?.observation;
        if (!obs) return '<div style="font-size:12px;color:#cbd5e1">No current observation</div>';
        const f = (v, d=1) => (typeof v === 'number' && Number.isFinite(v)) ? Number(v).toFixed(d) : '--';
        const rh = (typeof obs.rh === 'number' && Number.isFinite(obs.rh)) ? `${Math.round(obs.rh)}%` : '--';
        return `<div style="font-size:12px;line-height:1.35"><div><b>Temp:</b> ${f(obs.temp)} ${obs.tempUnit || ''}</div><div><b>Dew Point:</b> ${f(obs.dew)} ${obs.dewUnit || ''}</div><div><b>RH:</b> ${rh}</div><div><b>Wind:</b> ${f(obs.wind)} ${obs.windUnit || ''} ${obs.windDir || ''}</div><div><b>Pressure:</b> ${f(obs.pressure,2)} ${obs.pressureUnit || ''}</div><div><b>Obs Time:</b> ${obs.timestamp ? new Date(obs.timestamp).toLocaleString() : '--'}</div></div>`;
    }

    function renderWeatherStations(payload) {
        wxStations.layer.clearLayers();
        wxStations.byId.clear();
        if (!payload || !Array.isArray(payload.stations) || !wxStations.visible) return;

        wxStations.activeId = payload.activeStationId || null;

        for (const st of payload.stations) {
            if (typeof st?.lat !== 'number' || typeof st?.lon !== 'number') continue;
            const isActive = !!st.isActive;
            const obs = st.observation || null;
            const fmt = (v, d=0) => (typeof v === 'number' && Number.isFinite(v)) ? Number(v).toFixed(d) : '--';
            const iconHtml = `<div class="station-model ${isActive ? 'active' : 'idle'}"><div class="temp">${fmt(obs?.temp)}${obs?.tempUnit || ''}</div><div class="dew">${fmt(obs?.dew)}${obs?.dewUnit || ''}</div><div class="wind">${fmt(obs?.wind)} ${obs?.windUnit || ''}<br/>${obs?.windDir || ''}</div><div class="dot"></div></div>`;
            const marker = L.marker([st.lat, st.lon], {
                icon: L.divIcon({ className: '', html: iconHtml, iconSize: [96, 62], iconAnchor: [48, 31] })
            });

            const title = `<div style="font-weight:600">${st.id || 'Station'} — ${st.name || ''}</div><div style="font-size:12px;color:#94a3b8">${st.timeZone || ''}</div>`;
            marker.bindPopup(`<div style="min-width:320px;max-width:460px">${title}${formatObsPopup(st)}</div>`);
            marker.addTo(wxStations.layer);
            if (st.id) wxStations.byId.set(st.id, marker);
        }
    }

    window.setWeatherStations = function(payload) {
        wxStations.payload = payload;
        renderWeatherStations(payload);
    };

    window.setWeatherStationsVisible = function(on) {
        wxStations.visible = !!on;
        renderWeatherStations(wxStations.payload);
    };

    // =======================
    // Disable follow on user movement
    // =======================
    function disableFollow() {
        if (!followEnabled) return;

        followEnabled = false;

        if (window.chrome?.webview) {
            window.chrome.webview.postMessage(JSON.stringify({
                type: "followChanged",
                value: false
            }));
        }
    }

    map.on('dragstart', disableFollow);
    map.on('zoomstart', disableFollow);

    // =======================
// Radar (Animated Mosaic via IEM WMS-T)
// =======================
// Uses the IEM time-aware WMS endpoint. Each frame is a WMS layer with a different TIME parameter.
// Frame cadence is 5 minutes.
// Docs: https://mesonet.agron.iastate.edu/docs/nexrad_composites/ (nexrad-n0r-wmst layer)
(function () {
    const WMS_URL = "https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r-t.cgi";
    const WMS_LAYER = "nexrad-n0r-wmst";
    const FRAME_MINUTES = 5;
    const MAX_FRAMES = 30;

    let enabled = false;
    let frameCount = 10;
    let speedMs = 800;

    let frames = [];   // Date objects (UTC)
    let layers = [];
    let ready = [];    // boolean[] layer has loaded at least once
    let idx = 0;
    let visibleIdx = -1;
    let timer = null;
    let refreshTimer = null;

    // Floating overlay elements
    let overlayEl = null;
    let frameStampEl = null;
    let refreshStampEl = null;

    function roundDownTo5MinUtc(d) {
        const ms = d.getTime();
        const step = FRAME_MINUTES * 60 * 1000;
        return new Date(Math.floor(ms / step) * step);
    }

    function isoUtcNoMillis(d) {
        // YYYY-MM-DDTHH:mm:00Z
        const pad = (n) => String(n).padStart(2, "0");
        return `${d.getUTCFullYear()}-${pad(d.getUTCMonth() + 1)}-${pad(d.getUTCDate())}T${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}:00Z`;
    }

    function ensureControls() {
        if (overlayEl) return;

        overlayEl = document.getElementById('radarOverlay');
        frameStampEl = document.getElementById('radarFrameStamp');
        refreshStampEl = document.getElementById('radarRefreshStamp');

        // Click handling
        overlayEl.addEventListener('click', (e) => {
            const act = e.target?.getAttribute?.('data-act');
            if (!act) return;
            if (act === 'start') first();
            if (act === 'rew') prev();
            if (act === 'play') play();
            if (act === 'pause') pause();
            if (act === 'fwd') next();
            if (act === 'end') latest();
        });
    }

    function setFrameStamp(text) {
        ensureControls();
        if (frameStampEl) frameStampEl.textContent = text || '';
    }

    function setRefreshStamp(text) {
        ensureControls();
        if (refreshStampEl) refreshStampEl.textContent = text || '';
    }

    function clearLayers() {
        for (const l of layers) {
            try { map.removeLayer(l); } catch { }
        }
        layers = [];
        ready = [];
        visibleIdx = -1;
    }

    function formatFrameStamp(d) {
        if (!d) return '';
        return `Frame: ${d.toLocaleString()}`;
    }

    function show(i) {
        if (!layers.length) return;
        i = (i % layers.length + layers.length) % layers.length;

        // Avoid flicker: don't swap to a frame that hasn't loaded yet.
        if (!ready[i]) return;

        idx = i;

        if (visibleIdx >= 0 && layers[visibleIdx]) {
            try { layers[visibleIdx].setOpacity(0); } catch { }
        }

        const layer = layers[idx];
        if (!map.hasLayer(layer)) layer.addTo(map);
        layer.setOpacity(0.60);
        visibleIdx = idx;

        setFrameStamp(formatFrameStamp(frames[idx]));
    }

    function next() { if (layers.length) show(idx + 1); }
    function prev() { if (layers.length) show(idx - 1); }

    function first() {
        if (!layers.length) return;
        for (let i = 0; i < layers.length; i++) {
            if (ready[i]) { show(i); return; }
        }
    }

    function latest() {
        if (!layers.length) return;
        for (let i = layers.length - 1; i >= 0; i--) {
            if (ready[i]) { show(i); return; }
        }
    }

    function play() {
        if (timer || layers.length < 2) return;

        // If current isn't ready, jump to newest ready frame.
        if (!ready[idx]) {
            for (let i = ready.length - 1; i >= 0; i--) {
                if (ready[i]) { idx = i; break; }
            }
        }

        // When already at newest frame, start one step back so the next tick advances
        // forward instead of wrapping to the oldest frame.
        if (idx >= layers.length - 1 && layers.length > 1) {
            for (let i = layers.length - 2; i >= 0; i--) {
                if (ready[i]) { idx = i; break; }
            }
        }

        timer = setInterval(() => {
            if (!layers.length) return;

            // Advance until we hit a ready frame.
            for (let step = 1; step <= layers.length; step++) {
                const j = (idx + step) % layers.length;
                if (ready[j]) { show(j); break; }
            }
        }, speedMs);
    }

    function pause() {
        if (!timer) return;
        clearInterval(timer);
        timer = null;
    }

    function rebuildFrames() {
        if (!enabled) return;

        const wasPlaying = !!timer;
        pause();

        const now = roundDownTo5MinUtc(new Date());
        frames = [];
        for (let i = frameCount - 1; i >= 0; i--) {
            frames.push(new Date(now.getTime() - i * FRAME_MINUTES * 60 * 1000));
        }

        clearLayers();

        // Build + preload layers. We add them all at opacity 0 so tiles fetch immediately,
        // which prevents the "frame pops in one at a time" flicker when you hit play.
        layers = frames.map((d, i) => {
            const layer = L.tileLayer.wms(WMS_URL, {
                layers: WMS_LAYER,
                format: "image/png",
                transparent: true,
                opacity: 0,
                time: isoUtcNoMillis(d)
            });

            layer.on('load', () => {
                ready[i] = true;

                // First time anything loads, show something immediately.
                if (visibleIdx < 0) {
                    if (ready[newIdx]) show(newIdx);
                    else latest();

                    if (wasPlaying) setTimeout(() => play(), 50);
                    return;
                }

                // While paused (or before playback resumes), always drift forward to the
                // newest ready frame as tiles finish loading so refreshes don't appear to go backward.
                if (!timer) {
                    if (i >= idx) {
                        show(i);
                    }
                    else if (i === newIdx) {
                        show(i);
                    }
                }
            });

            return layer;
        });

        ready = new Array(layers.length).fill(false);

        // Start at newest frame by default.
        let newIdx = Math.max(0, frames.length - 1);

        // Add all layers to force tile fetch / cache (opacity 0)
        for (const l of layers) {
            try { l.addTo(map); } catch { }
        }

        // Prefer prior index; actual visible frame will be chosen when a layer loads.
        idx = newIdx;

        const local = new Date();
        setRefreshStamp(`Last refresh: ${local.toLocaleTimeString()}`);
    }

    function startAutoRefresh() {
        stopAutoRefresh();
        // Refresh frames while radar is enabled (keeps newest frames coming in)
        refreshTimer = setInterval(rebuildFrames, 2 * 60 * 1000);
    }

    function stopAutoRefresh() {
        if (refreshTimer) {
            clearInterval(refreshTimer);
            refreshTimer = null;
        }
    }

    function setEnabled(on) {
        enabled = !!on;
        ensureControls();

        // Show/hide the floating overlay controls.
        if (overlayEl) {
            overlayEl.classList.toggle('hidden', !enabled);
            overlayEl.setAttribute('aria-hidden', (!enabled).toString());
        }

        if (!enabled) {
            pause();
            stopAutoRefresh();
            clearLayers();
            frames = [];
            setFrameStamp('');
            setRefreshStamp('');
            return;
        }

        rebuildFrames();
        startAutoRefresh();
    }

    function setFrameCount(n) {
        const v = Math.max(1, Math.min(MAX_FRAMES, Math.round(Number(n) || 10)));
        frameCount = v;
        if (enabled) rebuildFrames();
    }

    function setSpeed(ms) {
        speedMs = Math.max(200, Math.round(Number(ms) || 800));
        if (timer) { pause(); play(); }
    }

    window.radar = {
        setEnabled,
        setFrameCount,
        setSpeed,
        next,
        prev,
        first,
        latest,
        play,
        pause
    };

    // Back-compat entry point
    window.setRadarEnabled = (on) => window.radar.setEnabled(on);
})();

    // =======================
    // Routing
    // =======================

    function postToHost(obj) {
        if (window.chrome?.webview) {
            window.chrome.webview.postMessage(JSON.stringify(obj));
        }
    }

    // =======================
    // Map Click -> Coordinates
    // =======================

    map.on('click', (e) => {
        postToHost({ type: "mapClick", lat: e.latlng.lat, lon: e.latlng.lng });
    });

    map.on('dblclick', (e) => {
        postToHost({ type: "mapDblClick", lat: e.latlng.lat, lon: e.latlng.lng });
    });

    // =======================
    // SPC Outlook Overlays
    // =======================

    const spc = {
        layers: {},
        enabled: { day1: false, day2: false, day3: false }
    };

    window.spc = spc;

    const spcUrls = {
        day1: "https://www.spc.noaa.gov/products/outlook/day1otlk_cat.nolyr.geojson",
        day2: "https://www.spc.noaa.gov/products/outlook/day2otlk_cat.nolyr.geojson",
        day3: "https://www.spc.noaa.gov/products/outlook/day3otlk_cat.nolyr.geojson"
    };

    const spcTextUrls = {
        day1: "https://www.spc.noaa.gov/products/outlook/day1otlk.txt",
        day2: "https://www.spc.noaa.gov/products/outlook/day2otlk.txt",
        day3: "https://www.spc.noaa.gov/products/outlook/day3otlk.txt"
    };

    const spcTextCache = {};

    async function getSpcText(dayKey) {
        if (spcTextCache[dayKey]) return spcTextCache[dayKey];
        try {
            const resp = await fetch(spcTextUrls[dayKey]);
            if (!resp.ok) throw new Error("SPC text fetch failed");
            const txt = await resp.text();
            spcTextCache[dayKey] = txt;
            return txt;
        } catch {
            return "SPC text unavailable.";
        }
    }

    function spcStyle(feature) {
        const p = feature?.properties || {};
        const label = (p.LABEL || p.label || p.RISK || p.risk || "").toString().toUpperCase();

        // SPC categorical palette (approx standard):
        // TSTM (General Thunder): light green
        // MRGL: dark green
        // SLGT: yellow
        // ENH: orange
        // MDT: red
        // HIGH: magenta
        let color = "#9AE6B4"; // TSTM default

        if (label.includes("MRGL") || label.includes("MARGINAL")) color = "#2F855A";
        if (label.includes("SLGT") || label.includes("SLIGHT"))   color = "#F6E05E";
        if (label.includes("ENH")  || label.includes("ENHANCED")) color = "#ED8936";
        if (label.includes("MDT")  || label.includes("MODERATE")) color = "#E53E3E";
        if (label.includes("HIGH"))                               color = "#D53F8C";

        let weight = 2;
        let fillOpacity = 0.28;
        if (label.includes("MDT") || label.includes("MODERATE")) fillOpacity = 0.34;
        if (label.includes("HIGH")) fillOpacity = 0.42;

        fillOpacity = Math.max(0.04, Math.min(0.85, fillOpacity * spcOpacityFactor));
        return { color, fillColor: color, weight, opacity: 0.98 * spcOpacityFactor, fillOpacity };
    }

    async function ensureSpcLayer(dayKey) {
        if (spc.layers[dayKey]) return spc.layers[dayKey];

        const url = spcUrls[dayKey];
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`SPC fetch failed: ${dayKey}`);

        const data = await resp.json();
        const layer = L.geoJSON(data, {
            style: spcStyle,
            onEachFeature: (feature, lyr) => {
                const p = feature?.properties || {};
                const label = (p.LABEL || p.label || p.RISK || p.risk || "SPC Outlook");
                lyr.on('click', async (ev) => {
                    const raw = await getSpcText(dayKey);
                    const text = raw.length > 1800 ? `${raw.slice(0, 1800)}

…` : raw;
                    const esc = (s) => String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    const html = `<div style="width:820px;max-width:86vw"><div style="font-weight:600;margin-bottom:6px">${esc(dayKey.toUpperCase())} • ${esc(label)}</div><pre style="white-space:pre-wrap;max-height:420px;overflow:auto;margin:0">${esc(text)}</pre></div>`;
                    L.popup({ maxWidth: 900, minWidth: 640 }).setLatLng(ev.latlng).setContent(html).openOn(map);
                });
            }
        });

        spc.layers[dayKey] = layer;
        return layer;
    }

    window.setSpcOutlook = async (dayKey, enabled) => {
        const key = (dayKey || "").toString().toLowerCase();
        if (!spcUrls[key]) return;

        spc.enabled[key] = !!enabled;

        try {
            if (spc.enabled[key]) {
                const lyr = await ensureSpcLayer(key);
                lyr.addTo(map);
            } else {
                if (spc.layers[key]) map.removeLayer(spc.layers[key]);
            }
        } catch (err) {
            postToHost({ type: "spcError", day: key, message: (err && err.message) ? err.message : String(err) });
        }
    };

    function showRouteError(msg) {
        L.popup()
            .setLatLng(map.getCenter())
            .setContent(`<b>Route failed</b><br>${msg}`)
            .openOn(map);
    }

    window.clearRoute = () => {
        if (routingControl) {
            map.removeControl(routingControl);
            routingControl = null;
        }
    };

    async function snapToRoad(baseUrl, lat, lon) {
        const url = `${baseUrl}/nearest/v1/driving/${lon},${lat}?number=1`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error("Nearest failed");

        const data = await resp.json();
        const loc = data?.waypoints?.[0]?.location;
        if (!loc) throw new Error("No nearest location");

        return L.latLng(loc[1], loc[0]);
    }

    window.setRouteDestination = async (destLat, destLon) => {

        if (!gpsMarker) {
            showRouteError("No GPS position yet.");
            return;
        }

        const primaryBase = "https://router.project-osrm.org";
        const fallbackBase = "https://routing.openstreetmap.de";

        const primaryRoute = `${primaryBase}/route/v1`;
        const fallbackRoute = `${fallbackBase}/routed-car/route/v1`;

        const startRaw = gpsMarker.getLatLng();
        const endRaw = L.latLng(destLat, destLon);

        window.clearRoute();

        try {
            const start = await snapToRoad(primaryBase, startRaw.lat, startRaw.lng);
            const end = await snapToRoad(primaryBase, endRaw.lat, endRaw.lng);

            const router = L.Routing.osrmv1({
                serviceUrl: primaryRoute,
                profile: "driving"
            });

            routingControl = L.Routing.control({
                router,
                waypoints: [start, end],
                routeWhileDragging: false,
                addWaypoints: false,
                draggableWaypoints: false,
                showAlternatives: false,
                fitSelectedRoutes: true,
                show: true
            }).addTo(map);

            routingControl.on("routingerror", async () => {
                try {
                    window.clearRoute();

                    const start2 = await snapToRoad(fallbackBase, startRaw.lat, startRaw.lng);
                    const end2 = await snapToRoad(fallbackBase, endRaw.lat, endRaw.lng);

                    const router2 = L.Routing.osrmv1({
                        serviceUrl: fallbackRoute,
                        profile: "driving"
                    });

                    routingControl = L.Routing.control({
                        router: router2,
                        waypoints: [start2, end2],
                        routeWhileDragging: false,
                        addWaypoints: false,
                        draggableWaypoints: false,
                        showAlternatives: false,
                        fitSelectedRoutes: true,
                        show: true
                    }).addTo(map);

                } catch (err2) {
                    showRouteError(err2.message);
                }
            });

        } catch (err) {
            showRouteError(err.message);
        }

        followEnabled = false;
        postToHost({ type: "followChanged", value: false });
    };

    // =======================
    // Alerts
    // =======================
    let didFitAlertsOnce = false;

    // If true, the polygon outline encodes the NWS "severity" field.
    let severityOutlineEnabled = true;
    let severityGlowEnabled = true;
    let severityStripesEnabled = true;

    window.setSeverityOutline = (enabled) => {
        severityOutlineEnabled = !!enabled;
        try { alertLayer.setStyle(alertStyle); } catch {}
    };

    window.setSeverityGlow = (enabled) => {
        severityGlowEnabled = !!enabled;
        try { alertLayer.setStyle(alertStyle); } catch {}
    };

    window.setSeverityStripes = (enabled) => {
        severityStripesEnabled = !!enabled;
        try { alertLayer.setStyle(alertStyle); } catch {}
    };

    // Hazard palette (Event -> "#RRGGBB")
    let hazardPalette = {};

    window.setHazardPalette = (paletteObj) => {
        hazardPalette = paletteObj || {};
        try { alertLayer.setStyle(alertStyle); } catch {}
    };

    // Look up event color using the active palette. Fallback if unknown.
    function eventColor(eventName) {
        const key = (eventName || "").toString().trim();
        if (!key) return "#A0A0A0";

        // Exact match first (case-sensitive keys in object, but we normalize below)
        if (hazardPalette[key]) return hazardPalette[key];

        // Case-insensitive match
        const lower = key.toLowerCase();
        for (const k in hazardPalette) {
            if ((k || "").toLowerCase() === lower) return hazardPalette[k];
        }

        return "#A0A0A0";
    }

    function severityStroke(severity) {
        const sev = (severity || "unknown").toString().toLowerCase();

        // Default outline
        let weight = 2;
        let dashArray = null;
        let opacity = 1.0;

        if (!severityOutlineEnabled) {
            return { weight: 2, dashArray: null, opacity: 1.0 };
        }

        if (sev === "extreme") {
            weight = 5;
            opacity = 1.0;
        } else if (sev === "severe") {
            weight = 4;
        } else if (sev === "moderate") {
            weight = 3;
        } else if (sev === "minor") {
            weight = 2;
            opacity = 0.95;
        } else {
            weight = 2;
            dashArray = "6,6";
            opacity = 0.9;
        }

        return { weight, dashArray, opacity };
    }

    function alertStyle(feature) {
        const p = feature.properties || {};
        const base = eventColor(p.event || p.Event || "");
        const sev = severityStroke(p.severity);

        return {
            color: base,
            fillColor: base,
            weight: sev.weight,
            opacity: sev.opacity,
            dashArray: sev.dashArray,
            fillOpacity: 0.18
        };
    }

    const alertLayer = L.geoJSON([], {
        style: alertStyle,
        onEachFeature: (feature, layer) => {
            const p = feature.properties || {};

            // Apply severity visual effects (optional)
            layer.on("add", () => {
                try {
                    ensureSvgDefs();
                    const sev = (p.severity || "").toString().toLowerCase();
                    const isExtreme = sev === "extreme";
                    if (!layer._path) return;

                    // Glow for Extreme
                    if (severityGlowEnabled && isExtreme) {
                        layer._path.style.filter = "url(#sevGlow)";
                    } else {
                        layer._path.style.filter = "";
                    }

                    // Stripes for Extreme
                    if (severityStripesEnabled && isExtreme) {
                        layer._path.setAttribute("fill", "url(#diagStripes)");
                    } else {
                        // restore to normal fill color
                        const base = eventColor(p.event || p.Event || "");
                        layer._path.setAttribute("fill", base);
                    }
                } catch {}
            });

            layer.on("click", () => {
                if (!p.id) return;

                if (window.chrome?.webview) {
                    window.chrome.webview.postMessage(JSON.stringify({
                        type: "polygonClicked",
                        id: p.id
                    }));
                }
            });
        }
    }).addTo(map);

    window.setAlerts = (geojsonText) => {
        const gj = JSON.parse(geojsonText);
        alertLayer.clearLayers();
        alertLayer.addData(gj);

        if (!didFitAlertsOnce) {
            didFitAlertsOnce = true;
            const b = alertLayer.getBounds();
            if (b && b.isValid())
                map.fitBounds(b, { padding: [20, 20] });
        }
    };

    window.clearAlerts = () => {
        alertLayer.clearLayers();
        didFitAlertsOnce = false;
    };

    // =======================
    // WebView2 Listener
    // =======================
    if (window.chrome?.webview) {
        window.chrome.webview.addEventListener('message', e => {
            try {
                const data = e.data;

                if (typeof data === "string" && data.trim().startsWith("{")) {
                    const obj = JSON.parse(data);
                    if (obj.type === "alerts" && obj.geojson) {
                        window.setAlerts(obj.geojson);
                        return;
                    }
                }

                window.setAlerts(data);
            } catch {}
        });
    }

    window.setRadarEnabled(false);

</script>
</body>
</html>