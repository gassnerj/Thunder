<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Routing -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css">
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

    <style>
        html, body, #map { height: 100%; margin: 0; }

        .leaflet-routing-container {
            background: rgba(0,0,0,0.8);
            color: white;
        }
    </style>
</head>
<body>
<div id="map"></div>

<script>

    // =======================
    // Map Base
    // =======================
    const map = L.map('map', { zoomControl: true }).setView([39.5, -98.35], 4);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18
    }).addTo(map);

    // =======================
    // State
    // =======================
    let followEnabled = true;
    let gpsMarker = null;
    let routingControl = null;
    let radarLayer = null;

    let trailPoints = [];
    const TRAIL_MAX_POINTS = 300;

    let lastZoom = map.getZoom();

    // =======================
    // GPS Marker + Trail
    // =======================
    const trailLine = L.polyline([], {
        weight: 3,
        opacity: 0.9
    }).addTo(map);

    function ensureMarker(lat, lon) {
        if (!gpsMarker) {
            gpsMarker = L.circleMarker([lat, lon], {
                radius: 8,
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(map);
        } else {
            gpsMarker.setLatLng([lat, lon]);
        }
    }

    function addTrailPoint(lat, lon) {
        trailPoints.push([lat, lon]);
        if (trailPoints.length > TRAIL_MAX_POINTS)
            trailPoints.shift();
        trailLine.setLatLngs(trailPoints);
    }

    // =======================
    // Exposed API (C#)
    // =======================
    window.setFollow = (enabled) => followEnabled = !!enabled;

    window.clearTrail = () => {
        trailPoints = [];
        trailLine.setLatLngs(trailPoints);
    };

    window.setView = (lat, lon, zoom) => {
        lastZoom = zoom;
        map.setView([lat, lon], zoom);
    };

    window.updateGps = (lat, lon, zoom, addToTrail) => {
        ensureMarker(lat, lon);
        if (addToTrail) addTrailPoint(lat, lon);

        if (followEnabled) {
            if (typeof zoom === "number" && zoom !== lastZoom) {
                lastZoom = zoom;
                map.setView([lat, lon], zoom, { animate: true });
            } else {
                map.panTo([lat, lon], { animate: true });
            }
        }
    };

    // =======================
    // Disable follow on user movement
    // =======================
    function disableFollow() {
        if (!followEnabled) return;

        followEnabled = false;

        if (window.chrome?.webview) {
            window.chrome.webview.postMessage(JSON.stringify({
                type: "followChanged",
                value: false
            }));
        }
    }

    map.on('dragstart', disableFollow);
    map.on('zoomstart', disableFollow);

    // =======================
    // Radar
    // =======================
    window.setRadarEnabled = (enabled) => {
        if (enabled) {
            if (!radarLayer) {
                radarLayer = L.tileLayer.wms(
                    "https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi",
                    {
                        layers: "nexrad-n0r-900913",
                        format: "image/png",
                        transparent: true,
                        opacity: 0.55
                    }
                );
            }
            radarLayer.addTo(map);
        } else {
            if (radarLayer) map.removeLayer(radarLayer);
        }
    };

    // =======================
    // Routing
    // =======================

    function postToHost(obj) {
        if (window.chrome?.webview) {
            window.chrome.webview.postMessage(JSON.stringify(obj));
        }
    }

    function showRouteError(msg) {
        L.popup()
            .setLatLng(map.getCenter())
            .setContent(`<b>Route failed</b><br>${msg}`)
            .openOn(map);
    }

    window.clearRoute = () => {
        if (routingControl) {
            map.removeControl(routingControl);
            routingControl = null;
        }
    };

    async function snapToRoad(baseUrl, lat, lon) {
        const url = `${baseUrl}/nearest/v1/driving/${lon},${lat}?number=1`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error("Nearest failed");

        const data = await resp.json();
        const loc = data?.waypoints?.[0]?.location;
        if (!loc) throw new Error("No nearest location");

        return L.latLng(loc[1], loc[0]);
    }

    window.setRouteDestination = async (destLat, destLon) => {

        if (!gpsMarker) {
            showRouteError("No GPS position yet.");
            return;
        }

        const primaryBase = "https://router.project-osrm.org";
        const fallbackBase = "https://routing.openstreetmap.de";

        const primaryRoute = `${primaryBase}/route/v1`;
        const fallbackRoute = `${fallbackBase}/routed-car/route/v1`;

        const startRaw = gpsMarker.getLatLng();
        const endRaw = L.latLng(destLat, destLon);

        window.clearRoute();

        try {
            const start = await snapToRoad(primaryBase, startRaw.lat, startRaw.lng);
            const end = await snapToRoad(primaryBase, endRaw.lat, endRaw.lng);

            const router = L.Routing.osrmv1({
                serviceUrl: primaryRoute,
                profile: "driving"
            });

            routingControl = L.Routing.control({
                router,
                waypoints: [start, end],
                routeWhileDragging: false,
                addWaypoints: false,
                draggableWaypoints: false,
                showAlternatives: false,
                fitSelectedRoutes: true,
                show: true
            }).addTo(map);

            routingControl.on("routingerror", async () => {
                try {
                    window.clearRoute();

                    const start2 = await snapToRoad(fallbackBase, startRaw.lat, startRaw.lng);
                    const end2 = await snapToRoad(fallbackBase, endRaw.lat, endRaw.lng);

                    const router2 = L.Routing.osrmv1({
                        serviceUrl: fallbackRoute,
                        profile: "driving"
                    });

                    routingControl = L.Routing.control({
                        router: router2,
                        waypoints: [start2, end2],
                        routeWhileDragging: false,
                        addWaypoints: false,
                        draggableWaypoints: false,
                        showAlternatives: false,
                        fitSelectedRoutes: true,
                        show: true
                    }).addTo(map);

                } catch (err2) {
                    showRouteError(err2.message);
                }
            });

        } catch (err) {
            showRouteError(err.message);
        }

        followEnabled = false;
        postToHost({ type: "followChanged", value: false });
    };

    // =======================
    // Alerts
    // =======================
    let didFitAlertsOnce = false;

    const alertLayer = L.geoJSON([], {
        style: (feature) => {
            const p = feature.properties || {};
            const sev = (p.severity || "unknown").toLowerCase();

            let color = "#4F8BFF";
            if (sev === "extreme") color = "#B026FF";
            else if (sev === "severe") color = "#FF3B30";
            else if (sev === "moderate") color = "#FF9500";
            else if (sev === "minor") color = "#FFD60A";

            return {
                color,
                fillColor: color,
                weight: 2,
                opacity: 1,
                fillOpacity: 0.18
            };
        },
        onEachFeature: (feature, layer) => {
            const p = feature.properties || {};
            layer.bindPopup(`<b>${p.event || "Alert"}</b><br>${p.headline || ""}`);

            layer.on("click", () => {
                if (!p.id) return;

                if (window.chrome?.webview) {
                    window.chrome.webview.postMessage(JSON.stringify({
                        type: "polygonClicked",
                        id: p.id
                    }));
                }
            });
        }
    }).addTo(map);

    window.setAlerts = (geojsonText) => {
        const gj = JSON.parse(geojsonText);
        alertLayer.clearLayers();
        alertLayer.addData(gj);

        if (!didFitAlertsOnce) {
            didFitAlertsOnce = true;
            const b = alertLayer.getBounds();
            if (b && b.isValid())
                map.fitBounds(b, { padding: [20, 20] });
        }
    };

    window.clearAlerts = () => {
        alertLayer.clearLayers();
        didFitAlertsOnce = false;
    };

    // =======================
    // WebView2 Listener
    // =======================
    if (window.chrome?.webview) {
        window.chrome.webview.addEventListener('message', e => {
            try {
                const data = e.data;

                if (typeof data === "string" && data.trim().startsWith("{")) {
                    const obj = JSON.parse(data);
                    if (obj.type === "alerts" && obj.geojson) {
                        window.setAlerts(obj.geojson);
                        return;
                    }
                }

                window.setAlerts(data);
            } catch {}
        });
    }

    window.setRadarEnabled(false);

</script>
</body>
</html>