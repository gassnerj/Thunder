<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        html, body, #map { height: 100%; margin: 0; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    // ---------------- Map base ----------------
    const map = L.map('map', { zoomControl: true }).setView([39.5, -98.35], 4);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18
    }).addTo(map);

    // ---------------- State ----------------
    let followEnabled = true;
    let gpsMarker = null;

    let trailPoints = [];
    const TRAIL_MAX_POINTS = 300;

    // Avoid snapping zoom constantly when following
    let lastZoom = map.getZoom();

    // ---------------- Marker + Trail ----------------
    const trailLine = L.polyline([], {
        weight: 3,
        opacity: 0.9,
        // keep above tiles, below polygons
        pane: "overlayPane"
    }).addTo(map);

    function ensureMarker(lat, lon) {
        if (!gpsMarker) {
            gpsMarker = L.circleMarker([lat, lon], {
                radius: 8,
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(map);
        } else {
            gpsMarker.setLatLng([lat, lon]);
        }
    }

    function addTrailPoint(lat, lon) {
        trailPoints.push([lat, lon]);
        if (trailPoints.length > TRAIL_MAX_POINTS) trailPoints.shift();
        trailLine.setLatLngs(trailPoints);
    }

    // ---------------- Exposed API for C# ----------------
    window.setFollow = (enabled) => { followEnabled = !!enabled; };
    window.getFollow = () => followEnabled;

    window.clearTrail = () => {
        trailPoints = [];
        trailLine.setLatLngs(trailPoints);
    };

    window.setMarker = (lat, lon) => { ensureMarker(lat, lon); };

    window.setView = (lat, lon, zoom) => {
        lastZoom = zoom;
        map.setView([lat, lon], zoom);
    };

    // Single call per GPS update from C#
    window.updateGps = (lat, lon, zoom, addToTrail) => {
        ensureMarker(lat, lon);

        if (addToTrail) addTrailPoint(lat, lon);

        if (followEnabled) {
            // Only change zoom if it actually changed (prevents "twitchy" behavior)
            if (typeof zoom === "number" && zoom !== lastZoom) {
                lastZoom = zoom;
                map.setView([lat, lon], zoom, { animate: true });
            } else {
                map.panTo([lat, lon], { animate: true });
            }
        }
    };

    // ---------------- Disable follow on user interaction ----------------
    function disableFollowBecauseUser() {
        if (!followEnabled) return;

        followEnabled = false;

        if (window.chrome?.webview) {
            window.chrome.webview.postMessage(JSON.stringify({
                type: "followChanged",
                value: false
            }));
        }
    }

    map.on('dragstart', disableFollowBecauseUser);
    map.on('zoomstart', disableFollowBecauseUser);

    // ---------------- Radar (FIXED) ----------------
    // RainViewer "nowcast" URL is not stable without selecting a timestamped frame.
    // Use IEM NEXRAD WMS instead (reliable).
    let radarLayer = null;

    window.setRadarEnabled = (enabled) => {
        if (enabled) {
            if (!radarLayer) {
                radarLayer = L.tileLayer.wms(
                    "https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi",
                    {
                        layers: "nexrad-n0r-900913",
                        format: "image/png",
                        transparent: true,
                        opacity: 0.55,
                        zIndex: 600
                    }
                );
            }
            radarLayer.addTo(map);
        } else {
            if (radarLayer) map.removeLayer(radarLayer);
        }
    };

    window.setRadarOpacity = (opacity) => {
        if (radarLayer) radarLayer.setOpacity(opacity);
    };

    // ---------------- Alerts / Polygons ----------------
    let didFitAlertsOnce = false;

    const alertLayer = L.geoJSON([], {
        style: (feature) => {
            const p = feature.properties || {};
            const sev = (p.severity || "Unknown").toLowerCase();

            let stroke = "#4F8BFF";
            let fill   = "#4F8BFF";

            if (sev === "extreme")       { stroke = "#B026FF"; fill = "#B026FF"; }
            else if (sev === "severe")   { stroke = "#FF3B30"; fill = "#FF3B30"; }
            else if (sev === "moderate") { stroke = "#FF9500"; fill = "#FF9500"; }
            else if (sev === "minor")    { stroke = "#FFD60A"; fill = "#FFD60A"; }

            const affects = !!p.affectsMe;
            const nearby  = !!p.isNearby;

            return {
                color: stroke,
                fillColor: fill,
                weight: affects ? 4 : 2,
                opacity: 1,
                fillOpacity: affects ? 0.28 : (nearby ? 0.16 : 0.12),
                // push above radar
                pane: "overlayPane"
            };
        },
        onEachFeature: (feature, layer) => {
            const p = feature.properties || {};
            const title = p.event || "Alert";
            const headline = p.headline || "";
            layer.bindPopup(`<b>${title}</b><br>${headline}`);
        }
    }).addTo(map);

    window.setAlerts = (geojsonText) => {
        const gj = JSON.parse(geojsonText);
        alertLayer.clearLayers();
        alertLayer.addData(gj);

        // Fit once (optional) so you don't keep snapping view
        if (!didFitAlertsOnce) {
            didFitAlertsOnce = true;
            try {
                const b = alertLayer.getBounds();
                if (b && b.isValid()) map.fitBounds(b, { padding: [20, 20] });
            } catch {}
        }
    };

    window.clearAlerts = () => {
        alertLayer.clearLayers();
        didFitAlertsOnce = false;
    };

    // WebView2 message handler:
    // - if you send raw FeatureCollection string: it will work
    // - if later you send JSON envelope {type:"alerts", geojson:"..."} it will work
    if (window.chrome?.webview) {
        window.chrome.webview.addEventListener('message', e => {
            try {
                const data = e.data;

                // If envelope format
                if (typeof data === "string" && data.trim().startsWith("{")) {
                    const obj = JSON.parse(data);
                    if (obj && obj.type === "alerts" && obj.geojson) {
                        window.setAlerts(obj.geojson);
                        return;
                    }
                }

                // Otherwise treat as FeatureCollection string
                window.setAlerts(data);
            } catch {
                // ignore
            }
        });
    }

    // Default: radar OFF until user toggles it (less surprise)
    window.setRadarEnabled(false);
</script>
</body>
</html>