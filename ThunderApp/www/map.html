<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        html, body, #map { height: 100%; margin: 0; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = L.map('map').setView([39.5, -98.35], 4);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18
    }).addTo(map);

    // ---------- State ----------
    let followEnabled = true;
    let gpsMarker = null;

    // Trail
    let trailLine = L.polyline([], { weight: 3, opacity: 0.9 }).addTo(map);
    let trailPoints = [];
    const TRAIL_MAX_POINTS = 300; // keep it bounded

    // ---------- Helpers ----------
    function ensureMarker(lat, lon) {
        if (!gpsMarker) {
            gpsMarker = L.circleMarker([lat, lon], {
                radius: 8,
                weight: 2,
                fillOpacity: 0.9
            }).addTo(map);
        } else {
            gpsMarker.setLatLng([lat, lon]);
        }
    }

    function addTrailPoint(lat, lon) {
        trailPoints.push([lat, lon]);
        if (trailPoints.length > TRAIL_MAX_POINTS) trailPoints.shift();
        trailLine.setLatLngs(trailPoints);
    }

    // ---------- Exposed API for C# ----------
    window.setFollow = (enabled) => {
        followEnabled = !!enabled;
    };

    window.getFollow = () => followEnabled;

    window.clearTrail = () => {
        trailPoints = [];
        trailLine.setLatLngs(trailPoints);
    };

    window.setMarker = (lat, lon) => {
        ensureMarker(lat, lon);
    };

    window.setView = (lat, lon, zoom) => {
        map.setView([lat, lon], zoom);
    };

    // One call from C# each update:
    window.updateGps = (lat, lon, zoom, addToTrail) => {
        ensureMarker(lat, lon);

        if (addToTrail) addTrailPoint(lat, lon);

        if (followEnabled) {
            // Pan instead of hard setView (feels smoother)
            map.setView([lat, lon], zoom, { animate: true });
        }
    };

    // ---------- User interaction disables follow ----------
    function disableFollowBecauseUser() {
        if (followEnabled) {
            followEnabled = false;
            // Optional: tell C# so your UI toggle stays in sync
            if (window.chrome?.webview) {
                window.chrome.webview.postMessage(JSON.stringify({ type: "followChanged", value: false }));
            }
        }
    }

    map.on('dragstart', disableFollowBecauseUser);
    map.on('zoomstart', disableFollowBecauseUser);

    let radarLayer = null;

    window.setRadarEnabled = (enabled) => {
        if (enabled) {
            if (!radarLayer) {
                radarLayer = L.tileLayer(
                    "https://tilecache.rainviewer.com/v2/radar/nowcast/{z}/{x}/{y}/2/1_1.png",
                    { opacity: 0.65, zIndex: 500 }
                );
            }
            radarLayer.addTo(map);
        } else {
            if (radarLayer) map.removeLayer(radarLayer);
        }
    };

    window.setRadarOpacity = (opacity) => {
        if (radarLayer) radarLayer.setOpacity(opacity);
    };
    
    let alertLayer = L.geoJSON([], {
        style: (feature) => {
            const p = feature.properties || {};
            const sev = (p.severity || "Unknown").toLowerCase();

            // NWS-ish severity palette
            // Extreme = magenta-ish
            // Severe  = red
            // Moderate= orange
            // Minor   = yellow
            // Unknown = blue/gray
            let stroke = "#4F8BFF";
            let fill   = "#4F8BFF";

            if (sev === "extreme")  { stroke = "#B026FF"; fill = "#B026FF"; }
            else if (sev === "severe")   { stroke = "#FF3B30"; fill = "#FF3B30"; }
            else if (sev === "moderate") { stroke = "#FF9500"; fill = "#FF9500"; }
            else if (sev === "minor")    { stroke = "#FFD60A"; fill = "#FFD60A"; }
            else if (sev === "unknown")  { stroke = "#4F8BFF"; fill = "#4F8BFF"; }

            const affects = !!p.affectsMe;
            const nearby  = !!p.isNearby;

            return {
                color: stroke,
                fillColor: fill,
                weight: affects ? 4 : 2,
                opacity: 1,
                fillOpacity: affects ? 0.28 : (nearby ? 0.16 : 0.12)
            };
        },
        onEachFeature: (feature, layer) => {
            const p = feature.properties || {};
            const title = p.event || "Alert";
            const headline = p.headline || "";
            layer.bindPopup(`<b>${title}</b><br>${headline}`);
        }
    }).addTo(map);

    window.setAlerts = (geojsonText) => {
        const gj = JSON.parse(geojsonText);
        alertLayer.clearLayers();
        alertLayer.addData(gj);

        // optional: zoom to alerts when first loaded
        try {
            const b = alertLayer.getBounds();
            if (b && b.isValid()) map.fitBounds(b, { padding: [20, 20] });
        } catch {}
    };

    window.clearAlerts = () => {
        alertLayer.clearLayers();
    };

    if (window.chrome?.webview) {
        window.chrome.webview.addEventListener('message', e => {
            // expecting a FeatureCollection JSON string
            setAlerts(e.data);
        });
    }

    setRadarEnabled(true);
</script>
</body>
</html>