<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Routing -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css">
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

    <style>
        html, body, #map { height: 100%; margin: 0; }

        .leaflet-routing-container {
            background: rgba(0,0,0,0.8);
            color: white;
        }
    </style>
</head>
<body>
<div id="map"></div>

<script>

    // =======================
    // Map Base
    // =======================
    const map = L.map('map', { zoomControl: true, doubleClickZoom: false }).setView([39.5, -98.35], 4);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18
    }).addTo(map);

    // =======================
    // State
    // =======================
    let followEnabled = true;
    let gpsMarker = null;
    let routingControl = null;
    let radarLayer = null;

    // Range circle
    let rangeCircle = null;
    let rangeCircleEnabled = false;
    let rangeCircleMiles = 50;

    let trailPoints = [];
    const TRAIL_MAX_POINTS = 300;

    let lastZoom = map.getZoom();

    // =======================
    // GPS Marker + Trail
    // =======================
    const trailLine = L.polyline([], {
        weight: 3,
        opacity: 0.9
    }).addTo(map);

    function ensureMarker(lat, lon) {
        if (!gpsMarker) {
            gpsMarker = L.circleMarker([lat, lon], {
                radius: 8,
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(map);
        } else {
            gpsMarker.setLatLng([lat, lon]);
        }
    }

    function addTrailPoint(lat, lon) {
        trailPoints.push([lat, lon]);
        if (trailPoints.length > TRAIL_MAX_POINTS)
            trailPoints.shift();
        trailLine.setLatLngs(trailPoints);
    }

    // =======================
    // Exposed API (C#)
    // =======================
    window.setFollow = (enabled) => followEnabled = !!enabled;

    window.clearTrail = () => {
        trailPoints = [];
        trailLine.setLatLngs(trailPoints);
    };

    window.setView = (lat, lon, zoom) => {
        lastZoom = zoom;
        map.setView([lat, lon], zoom);
    };

    window.updateGps = (lat, lon, zoom, addToTrail) => {
        ensureMarker(lat, lon);
        if (addToTrail) addTrailPoint(lat, lon);

        // keep range circle centered on GPS
        if (rangeCircleEnabled) {
            ensureRangeCircle(lat, lon, rangeCircleMiles);
        }

        if (followEnabled) {
            if (typeof zoom === "number" && zoom !== lastZoom) {
                lastZoom = zoom;
                map.setView([lat, lon], zoom, { animate: true });
            } else {
                map.panTo([lat, lon], { animate: true });
            }
        }
    };

    // =======================
    // Range Circle (miles)
    // =======================

    function ensureRangeCircle(lat, lon, miles) {
        const meters = (miles || 0) * 1609.344;
        if (!rangeCircle) {
            rangeCircle = L.circle([lat, lon], {
                radius: meters,
                weight: 2,
                opacity: 0.9,
                fillOpacity: 0.06
            }).addTo(map);
        } else {
            rangeCircle.setLatLng([lat, lon]);
            rangeCircle.setRadius(meters);
        }
    }

    window.setRangeCircle = (lat, lon, enabled, miles) => {
        rangeCircleEnabled = !!enabled;
        rangeCircleMiles = (typeof miles === "number") ? miles : parseFloat(miles);

        if (!rangeCircleEnabled) {
            if (rangeCircle) {
                map.removeLayer(rangeCircle);
                rangeCircle = null;
            }
            return;
        }

        if (typeof lat !== "number") lat = parseFloat(lat);
        if (typeof lon !== "number") lon = parseFloat(lon);

        // Prefer GPS marker center if available
        if (gpsMarker) {
            const p = gpsMarker.getLatLng();
            ensureRangeCircle(p.lat, p.lng, rangeCircleMiles);
        } else {
            ensureRangeCircle(lat, lon, rangeCircleMiles);
        }
    };

    // =======================
    // Disable follow on user movement
    // =======================
    function disableFollow() {
        if (!followEnabled) return;

        followEnabled = false;

        if (window.chrome?.webview) {
            window.chrome.webview.postMessage(JSON.stringify({
                type: "followChanged",
                value: false
            }));
        }
    }

    map.on('dragstart', disableFollow);
    map.on('zoomstart', disableFollow);

    // =======================
    // Radar
    // =======================
    window.setRadarEnabled = (enabled) => {
        if (enabled) {
            if (!radarLayer) {
                radarLayer = L.tileLayer.wms(
                    "https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi",
                    {
                        layers: "nexrad-n0r-900913",
                        format: "image/png",
                        transparent: true,
                        opacity: 0.55
                    }
                );
            }
            radarLayer.addTo(map);
        } else {
            if (radarLayer) map.removeLayer(radarLayer);
        }
    };

    // =======================
    // Routing
    // =======================

    function postToHost(obj) {
        if (window.chrome?.webview) {
            window.chrome.webview.postMessage(JSON.stringify(obj));
        }
    }

    // =======================
    // Map Click -> Coordinates
    // =======================

    map.on('click', (e) => {
        postToHost({ type: "mapClick", lat: e.latlng.lat, lon: e.latlng.lng });
    });

    map.on('dblclick', (e) => {
        postToHost({ type: "mapDblClick", lat: e.latlng.lat, lon: e.latlng.lng });
    });

    // =======================
    // SPC Outlook Overlays
    // =======================

    const spc = {
        layers: {},
        enabled: { day1: false, day2: false, day3: false }
    };

    const spcUrls = {
        day1: "https://www.spc.noaa.gov/products/outlook/day1otlk_cat.nolyr.geojson",
        day2: "https://www.spc.noaa.gov/products/outlook/day2otlk_cat.nolyr.geojson",
        day3: "https://www.spc.noaa.gov/products/outlook/day3otlk_cat.nolyr.geojson"
    };

    function spcStyle(feature) {
        const p = feature?.properties || {};
        const label = (p.LABEL || p.label || p.RISK || p.risk || "").toString().toUpperCase();

        // SPC categorical palette (approx standard):
        // TSTM (General Thunder): light green
        // MRGL: dark green
        // SLGT: yellow
        // ENH: orange
        // MDT: red
        // HIGH: magenta
        let color = "#9AE6B4"; // TSTM default

        if (label.includes("MRGL") || label.includes("MARGINAL")) color = "#2F855A";
        if (label.includes("SLGT") || label.includes("SLIGHT"))   color = "#F6E05E";
        if (label.includes("ENH")  || label.includes("ENHANCED")) color = "#ED8936";
        if (label.includes("MDT")  || label.includes("MODERATE")) color = "#E53E3E";
        if (label.includes("HIGH"))                               color = "#D53F8C";

        let weight = 2;
        let fillOpacity = 0.12;
        if (label.includes("MDT") || label.includes("MODERATE")) fillOpacity = 0.16;
        if (label.includes("HIGH")) fillOpacity = 0.20;

        return { color, fillColor: color, weight, opacity: 0.95, fillOpacity };
    }

    async function ensureSpcLayer(dayKey) {
        if (spc.layers[dayKey]) return spc.layers[dayKey];

        const url = spcUrls[dayKey];
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`SPC fetch failed: ${dayKey}`);

        const data = await resp.json();
        const layer = L.geoJSON(data, {
            style: spcStyle,
            onEachFeature: (feature, lyr) => {
                const p = feature?.properties || {};
                const label = (p.LABEL || p.label || p.RISK || p.risk || "SPC Outlook");
                lyr.bindTooltip(label, { sticky: true });
            }
        });

        spc.layers[dayKey] = layer;
        return layer;
    }

    window.setSpcOutlook = async (dayKey, enabled) => {
        const key = (dayKey || "").toString().toLowerCase();
        if (!spcUrls[key]) return;

        spc.enabled[key] = !!enabled;

        try {
            if (spc.enabled[key]) {
                const lyr = await ensureSpcLayer(key);
                lyr.addTo(map);
            } else {
                if (spc.layers[key]) map.removeLayer(spc.layers[key]);
            }
        } catch (err) {
            postToHost({ type: "spcError", day: key, message: (err && err.message) ? err.message : String(err) });
        }
    };

    function showRouteError(msg) {
        L.popup()
            .setLatLng(map.getCenter())
            .setContent(`<b>Route failed</b><br>${msg}`)
            .openOn(map);
    }

    window.clearRoute = () => {
        if (routingControl) {
            map.removeControl(routingControl);
            routingControl = null;
        }
    };

    async function snapToRoad(baseUrl, lat, lon) {
        const url = `${baseUrl}/nearest/v1/driving/${lon},${lat}?number=1`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error("Nearest failed");

        const data = await resp.json();
        const loc = data?.waypoints?.[0]?.location;
        if (!loc) throw new Error("No nearest location");

        return L.latLng(loc[1], loc[0]);
    }

    window.setRouteDestination = async (destLat, destLon) => {

        if (!gpsMarker) {
            showRouteError("No GPS position yet.");
            return;
        }

        const primaryBase = "https://router.project-osrm.org";
        const fallbackBase = "https://routing.openstreetmap.de";

        const primaryRoute = `${primaryBase}/route/v1`;
        const fallbackRoute = `${fallbackBase}/routed-car/route/v1`;

        const startRaw = gpsMarker.getLatLng();
        const endRaw = L.latLng(destLat, destLon);

        window.clearRoute();

        try {
            const start = await snapToRoad(primaryBase, startRaw.lat, startRaw.lng);
            const end = await snapToRoad(primaryBase, endRaw.lat, endRaw.lng);

            const router = L.Routing.osrmv1({
                serviceUrl: primaryRoute,
                profile: "driving"
            });

            routingControl = L.Routing.control({
                router,
                waypoints: [start, end],
                routeWhileDragging: false,
                addWaypoints: false,
                draggableWaypoints: false,
                showAlternatives: false,
                fitSelectedRoutes: true,
                show: true
            }).addTo(map);

            routingControl.on("routingerror", async () => {
                try {
                    window.clearRoute();

                    const start2 = await snapToRoad(fallbackBase, startRaw.lat, startRaw.lng);
                    const end2 = await snapToRoad(fallbackBase, endRaw.lat, endRaw.lng);

                    const router2 = L.Routing.osrmv1({
                        serviceUrl: fallbackRoute,
                        profile: "driving"
                    });

                    routingControl = L.Routing.control({
                        router: router2,
                        waypoints: [start2, end2],
                        routeWhileDragging: false,
                        addWaypoints: false,
                        draggableWaypoints: false,
                        showAlternatives: false,
                        fitSelectedRoutes: true,
                        show: true
                    }).addTo(map);

                } catch (err2) {
                    showRouteError(err2.message);
                }
            });

        } catch (err) {
            showRouteError(err.message);
        }

        followEnabled = false;
        postToHost({ type: "followChanged", value: false });
    };

    // =======================
    // Alerts
    // =======================
    let didFitAlertsOnce = false;

    // If true, the polygon outline encodes the NWS "severity" field.
    let severityOutlineEnabled = true;

    window.setSeverityOutline = (enabled) => {
        severityOutlineEnabled = !!enabled;
        // Restyle without rebuilding data.
        try { alertLayer.setStyle(alertStyle); } catch {}
    };

    // Official-ish event palette (WWA) for common hazards.
    function eventColor(eventName) {
        const e = (eventName || "").toString().toLowerCase();

        // Core chase-critical
        if (e.includes("tornado warning")) return "#FF0000";
        if (e.includes("severe thunderstorm warning")) return "#FFA500";
        if (e.includes("flash flood warning")) return "#8B0000";
        if (e.includes("extreme wind warning")) return "#FF8C00";

        // Watches
        if (e.includes("tornado watch")) return "#FFCC00";
        if (e.includes("severe thunderstorm watch")) return "#FFCC00";

        // Flood products
        if (e.includes("flood warning")) return "#00A651";
        if (e.includes("flood advisory")) return "#00C17D";
        if (e.includes("flood watch")) return "#2E8B57";

        // Fire
        if (e.includes("red flag warning")) return "#FF1493";
        if (e.includes("fire weather watch")) return "#FF69B4";

        // Winter (basic)
        if (e.includes("blizzard warning")) return "#FF69B4";
        if (e.includes("winter storm warning")) return "#FF69B4";
        if (e.includes("ice storm warning")) return "#8A2BE2";

        // Fallback
        return "#6B7280"; // slate
    }

    function severityStroke(severity) {
        const sev = (severity || "unknown").toString().toLowerCase();

        // Default outline
        let weight = 2;
        let dashArray = null;
        let opacity = 1.0;

        if (!severityOutlineEnabled) {
            return { weight: 2, dashArray: null, opacity: 1.0 };
        }

        if (sev === "extreme") {
            weight = 5;
            opacity = 1.0;
        } else if (sev === "severe") {
            weight = 4;
        } else if (sev === "moderate") {
            weight = 3;
        } else if (sev === "minor") {
            weight = 2;
            opacity = 0.95;
        } else {
            weight = 2;
            dashArray = "6,6";
            opacity = 0.9;
        }

        return { weight, dashArray, opacity };
    }

    function alertStyle(feature) {
        const p = feature.properties || {};
        const base = eventColor(p.event || p.Event || "");
        const sev = severityStroke(p.severity);

        return {
            color: base,
            fillColor: base,
            weight: sev.weight,
            opacity: sev.opacity,
            dashArray: sev.dashArray,
            fillOpacity: 0.18
        };
    }

    const alertLayer = L.geoJSON([], {
        style: alertStyle,
        onEachFeature: (feature, layer) => {
            const p = feature.properties || {};
            layer.bindPopup(`<b>${p.event || "Alert"}</b><br>${p.headline || ""}`);

            layer.on("click", () => {
                if (!p.id) return;

                if (window.chrome?.webview) {
                    window.chrome.webview.postMessage(JSON.stringify({
                        type: "polygonClicked",
                        id: p.id
                    }));
                }
            });
        }
    }).addTo(map);

    window.setAlerts = (geojsonText) => {
        const gj = JSON.parse(geojsonText);
        alertLayer.clearLayers();
        alertLayer.addData(gj);

        if (!didFitAlertsOnce) {
            didFitAlertsOnce = true;
            const b = alertLayer.getBounds();
            if (b && b.isValid())
                map.fitBounds(b, { padding: [20, 20] });
        }
    };

    window.clearAlerts = () => {
        alertLayer.clearLayers();
        didFitAlertsOnce = false;
    };

    // =======================
    // WebView2 Listener
    // =======================
    if (window.chrome?.webview) {
        window.chrome.webview.addEventListener('message', e => {
            try {
                const data = e.data;

                if (typeof data === "string" && data.trim().startsWith("{")) {
                    const obj = JSON.parse(data);
                    if (obj.type === "alerts" && obj.geojson) {
                        window.setAlerts(obj.geojson);
                        return;
                    }
                }

                window.setAlerts(data);
            } catch {}
        });
    }

    window.setRadarEnabled(false);

</script>
</body>
</html>